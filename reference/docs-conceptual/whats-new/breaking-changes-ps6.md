---
ms.date: 05/17/2018
keywords: PowerShell, a core
title: PowerShell 6.0 használhatatlanná tévő változásai
ms.openlocfilehash: d477a9b27e8d5df6653ee40f8b606879b60a80c7
ms.sourcegitcommit: 548547b2d5fc73e726bb9fec6175d452a351d975
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 12/20/2018
ms.locfileid: "53655446"
---
# <a name="breaking-changes-for-powershell-60"></a><span data-ttu-id="cece5-103">PowerShell 6.0 használhatatlanná tévő változásai</span><span class="sxs-lookup"><span data-stu-id="cece5-103">Breaking Changes for PowerShell 6.0</span></span>

## <a name="features-no-longer-available-in-powershell-core"></a><span data-ttu-id="cece5-104">A funkciók már nem érhető el, a PowerShell Core</span><span class="sxs-lookup"><span data-stu-id="cece5-104">Features no longer available in PowerShell Core</span></span>

### <a name="powershell-workflow"></a><span data-ttu-id="cece5-105">PowerShell-munkafolyamat</span><span class="sxs-lookup"><span data-stu-id="cece5-105">PowerShell Workflow</span></span>

<span data-ttu-id="cece5-106">[PowerShell-munkafolyamat] [ workflow] funkció a Windows PowerShellben, amely összeállítja a [Windows Workflow Foundation (WF)] [ workflow-foundation] , amely lehetővé teszi a létrehozása robusztus runbookok hosszan futó vagy párhuzamos feladatok.</span><span class="sxs-lookup"><span data-stu-id="cece5-106">[PowerShell Workflow][workflow] is a feature in Windows PowerShell that builds on top of [Windows Workflow Foundation (WF)][workflow-foundation] that enables the creation of robust runbooks for long-running or parallelized tasks.</span></span>

<span data-ttu-id="cece5-107">A Windows Workflow Foundation a .NET Core támogatása hiánya miatt nem folytatjuk a PowerShell Core a PowerShell-munkafolyamat támogatásához.</span><span class="sxs-lookup"><span data-stu-id="cece5-107">Due to the lack of support for Windows Workflow Foundation in .NET Core, we will not continue to support PowerShell Workflow in PowerShell Core.</span></span>

<span data-ttu-id="cece5-108">A későbbiekben szeretnénk natív PowerShell-munkafolyamat nélkül PowerShell nyelven párhuzamosság/egyidejűségi engedélyezéséhez.</span><span class="sxs-lookup"><span data-stu-id="cece5-108">In the future, we would like to enable native parallelism/concurrency in the PowerShell language without the need for PowerShell Workflow.</span></span>

[workflow]: https://docs.microsoft.com/powershell/scripting/core-powershell/workflows-guide
[workflow-foundation]: https://docs.microsoft.com/dotnet/framework/windows-workflow-foundation/

### <a name="custom-snap-ins"></a><span data-ttu-id="cece5-109">Egyéni beépülő modulok</span><span class="sxs-lookup"><span data-stu-id="cece5-109">Custom snap-ins</span></span>

<span data-ttu-id="cece5-110">[PowerShell beépülő modulok] [ snapin] vannak a megelőző, a PowerShell-modulokat, amelyek nem rendelkeznek széles körű bevezetési a PowerShell-Közösségben.</span><span class="sxs-lookup"><span data-stu-id="cece5-110">[PowerShell snap-ins][snapin] are a predecessor to PowerShell modules that do not have widespread adoption in the PowerShell community.</span></span>

<span data-ttu-id="cece5-111">A beépülő modulok és használati hiánya miatt a közösségi összetettsége miatt már nem támogatott egyéni beépülő modulokat a PowerShell Core.</span><span class="sxs-lookup"><span data-stu-id="cece5-111">Due to the complexity of supporting snap-ins and their lack of usage in the community, we no longer support custom snap-ins in PowerShell Core.</span></span>

<span data-ttu-id="cece5-112">Jelenleg ez megszünteti a `ActiveDirectory` és `DnsClient` modulok a Windows és Windows Server.</span><span class="sxs-lookup"><span data-stu-id="cece5-112">Today, this breaks the `ActiveDirectory` and `DnsClient` modules in Windows and Windows Server.</span></span>

[snapin]: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_pssnapins

### <a name="wmi-v1-cmdlets"></a><span data-ttu-id="cece5-113">A WMI v1-parancsmagok</span><span class="sxs-lookup"><span data-stu-id="cece5-113">WMI v1 cmdlets</span></span>

<span data-ttu-id="cece5-114">WMI-alapú modulok két csoportját támogató összetettsége miatt a WMI v1-parancsmagok a PowerShell Core eltávolítottuk:</span><span class="sxs-lookup"><span data-stu-id="cece5-114">Due to the complexity of supporting two sets of WMI-based modules, we removed the WMI v1 cmdlets from PowerShell Core:</span></span>

- `Get-WmiObject`
- `Invoke-WmiMethod`
- `Register-WmiEvent`
- `Set-WmiInstance`

<span data-ttu-id="cece5-115">Ehelyett azt javasoljuk, hogy Ön a (más néven WMI v2) CIM-parancsmagok, amelyek ugyanazt a funkcionalitást biztosítják rendelkező új funkciókat és a egy áttervezett szintaxis használata:</span><span class="sxs-lookup"><span data-stu-id="cece5-115">Instead, we recommend that you the use the CIM (aka WMI v2) cmdlets which provide the same functionality with new functionality and a redesigned syntax:</span></span>

- `Get-CimAssociatedInstance`
- `Get-CimClass`
- `Get-CimInstance`
- `Get-CimSession`
- `Invoke-CimMethod`
- `New-CimInstance`
- `New-CimSession`
- `New-CimSessionOption`
- `Register-CimIndicationEvent`
- `Remove-CimInstance`
- `Remove-CimSession`
- `Set-CimInstance`

### <a name="microsoftpowershelllocalaccounts"></a><span data-ttu-id="cece5-116">Microsoft.PowerShell.LocalAccounts</span><span class="sxs-lookup"><span data-stu-id="cece5-116">Microsoft.PowerShell.LocalAccounts</span></span>

<span data-ttu-id="cece5-117">Nem támogatott API-k használata miatt `Microsoft.PowerShell.LocalAccounts` el lett távolítva a PowerShell Core mindaddig, amíg egy jobb megoldás található.</span><span class="sxs-lookup"><span data-stu-id="cece5-117">Due to the use of unsupported APIs, `Microsoft.PowerShell.LocalAccounts` has been removed from PowerShell Core until a better solution is found.</span></span>

### <a name="-counter-cmdlets"></a><span data-ttu-id="cece5-118">`*-Counter` parancsmagjai</span><span class="sxs-lookup"><span data-stu-id="cece5-118">`*-Counter` cmdlets</span></span>

<span data-ttu-id="cece5-119">Nem támogatott API-k használata miatt a `*-Counter` el lett távolítva a PowerShell Core mindaddig, amíg egy jobb megoldás található.</span><span class="sxs-lookup"><span data-stu-id="cece5-119">Due to the use of unsupported APIs, the `*-Counter` has been removed from PowerShell Core until a better solution is found.</span></span>

## <a name="enginelanguage-changes"></a><span data-ttu-id="cece5-120">Összetevő/nyelvi változások</span><span class="sxs-lookup"><span data-stu-id="cece5-120">Engine/language changes</span></span>

### <a name="rename-powershellexe-to-pwshexe-5101httpsgithubcompowershellpowershellissues5101"></a><span data-ttu-id="cece5-121">Nevezze át `powershell.exe` való `pwsh.exe` [#5101](https://github.com/PowerShell/PowerShell/issues/5101)</span><span class="sxs-lookup"><span data-stu-id="cece5-121">Rename `powershell.exe` to `pwsh.exe` [#5101](https://github.com/PowerShell/PowerShell/issues/5101)</span></span>

<span data-ttu-id="cece5-122">Annak érdekében, hogy a felhasználóknak engedélyezi a Windows (ellentétben a Windows PowerShell) a PowerShell Core meghívásához determinisztikus módon, a PowerShell Core bináris módosult a `pwsh.exe` a Windows és `pwsh` nem Windows platformokon.</span><span class="sxs-lookup"><span data-stu-id="cece5-122">In order to give users a deterministic way to call PowerShell Core on Windows (as opposed to Windows PowerShell), the PowerShell Core binary was changed to `pwsh.exe` on Windows and `pwsh` on non-Windows platforms.</span></span>

<span data-ttu-id="cece5-123">Akkor használhatja rövidített nevét is – nem Windows platformokon ismertetése az elnevezési összhangban.</span><span class="sxs-lookup"><span data-stu-id="cece5-123">The shortened name is also consistent with naming of shells on non-Windows platforms.</span></span>

### <a name="dont-insert-line-breaks-to-output-except-for-tables-5193httpsgithubcompowershellpowershellissues5193"></a><span data-ttu-id="cece5-124">Ne szúrjon be a sortörések (kivéve a táblák) kimeneti [#5193](https://github.com/PowerShell/PowerShell/issues/5193)</span><span class="sxs-lookup"><span data-stu-id="cece5-124">Don't insert line breaks to output (except for tables) [#5193](https://github.com/PowerShell/PowerShell/issues/5193)</span></span>

<span data-ttu-id="cece5-125">Korábban a szélességét, a konzol kimenete lett igazítva, és sortörések, azaz a kimenet nem get újraformázta várható, ha a terminálon lett méretezve, a konzol tartomány zárószélessége lettek hozzáadva.</span><span class="sxs-lookup"><span data-stu-id="cece5-125">Previously, output was aligned to the width of the console and line breaks were added at the end width of the console, meaning the output didn't get reformatted as expected if the terminal was resized.</span></span> <span data-ttu-id="cece5-126">Ez a változás nem alkalmazták táblákat, a sortörések az oszlopokat, igazítva, szükség szerint.</span><span class="sxs-lookup"><span data-stu-id="cece5-126">This change was not applied to tables, as the line breaks are necessary to keep the columns aligned.</span></span>

### <a name="skip-null-element-check-for-collections-with-a-value-type-element-type-5432httpsgithubcompowershellpowershellissues5432"></a><span data-ttu-id="cece5-127">Hagyja ki a gyűjteményeket, amelyek egy értéktípus elem típusa null-elem keresése [#5432](https://github.com/PowerShell/PowerShell/issues/5432)</span><span class="sxs-lookup"><span data-stu-id="cece5-127">Skip null-element check for collections with a value-type element type [#5432](https://github.com/PowerShell/PowerShell/issues/5432)</span></span>

<span data-ttu-id="cece5-128">Az a `Mandatory` paraméter és `ValidateNotNull` és `ValidateNotNullOrEmpty` attribútumok, az elemhez null-ellenőrzés kihagyása, ha a gyűjtemény elem típusa typ hodnoty.</span><span class="sxs-lookup"><span data-stu-id="cece5-128">For the `Mandatory` parameter and `ValidateNotNull` and `ValidateNotNullOrEmpty` attributes, skip the null-element check if the collection's element type is value type.</span></span>

### <a name="change-outputencoding-to-use-utf-8-nobom-encoding-rather-than-ascii-5369httpsgithubcompowershellpowershellissues5369"></a><span data-ttu-id="cece5-129">Változás `$OutputEncoding` használandó `UTF-8 NoBOM` ASCII helyett kódolás [#5369](https://github.com/PowerShell/PowerShell/issues/5369)</span><span class="sxs-lookup"><span data-stu-id="cece5-129">Change `$OutputEncoding` to use `UTF-8 NoBOM` encoding rather than ASCII [#5369](https://github.com/PowerShell/PowerShell/issues/5369)</span></span>

<span data-ttu-id="cece5-130">Az előző kódolással, ASCII (7 bites), a kimenet bizonyos esetekben helytelen lapjával eredményez.</span><span class="sxs-lookup"><span data-stu-id="cece5-130">The previous encoding, ASCII (7-bit), would result in incorrect alteration of the output in some cases.</span></span> <span data-ttu-id="cece5-131">Ez a változás, hogy `UTF-8 NoBOM` alapértelmezett, amely Unicode kimeneti megőrzi a legtöbb eszközöket és operációs rendszerek által támogatott kódolást.</span><span class="sxs-lookup"><span data-stu-id="cece5-131">This change is to make `UTF-8 NoBOM` default, which preserves Unicode output with an encoding supported by most tools and operating systems.</span></span>

### <a name="remove-allscope-from-most-default-aliases-5268httpsgithubcompowershellpowershellissues5268"></a><span data-ttu-id="cece5-132">Távolítsa el `AllScope` a legtöbb alapértelmezett aliasok [#5268](https://github.com/PowerShell/PowerShell/issues/5268)</span><span class="sxs-lookup"><span data-stu-id="cece5-132">Remove `AllScope` from most default aliases [#5268](https://github.com/PowerShell/PowerShell/issues/5268)</span></span>

<span data-ttu-id="cece5-133">Hatókör létrehozása, felgyorsítása érdekében `AllScope` legtöbb alapértelmezett aliasok el lett távolítva.</span><span class="sxs-lookup"><span data-stu-id="cece5-133">To speed up scope creation, `AllScope` was removed from most default aliases.</span></span> <span data-ttu-id="cece5-134">`AllScope` maradt néhány gyakran használt aliasok ahol a keresési gyorsabb lett.</span><span class="sxs-lookup"><span data-stu-id="cece5-134">`AllScope` was left for a few frequently used aliases where the lookup was faster.</span></span>

### <a name="-verbose-and--debug-no-longer-overrides-erroractionpreference-5113httpsgithubcompowershellpowershellissues5113"></a><span data-ttu-id="cece5-135">`-Verbose` és `-Debug` már nem felülbírálások `$ErrorActionPreference` [#5113](https://github.com/PowerShell/PowerShell/issues/5113)</span><span class="sxs-lookup"><span data-stu-id="cece5-135">`-Verbose` and `-Debug` no longer overrides `$ErrorActionPreference` [#5113](https://github.com/PowerShell/PowerShell/issues/5113)</span></span>

<span data-ttu-id="cece5-136">Korábban Ha `-Verbose` vagy `-Debug` van megadva, akkor overrode viselkedését `$ErrorActionPreference`.</span><span class="sxs-lookup"><span data-stu-id="cece5-136">Previously, if `-Verbose` or `-Debug` were specified, it overrode the behavior of `$ErrorActionPreference`.</span></span> <span data-ttu-id="cece5-137">Ezzel `-Verbose` és `-Debug` már nem befolyásolja a működését `$ErrorActionPreference`.</span><span class="sxs-lookup"><span data-stu-id="cece5-137">With this change, `-Verbose` and `-Debug` no longer affect the behavior of `$ErrorActionPreference`.</span></span>

## <a name="cmdlet-changes"></a><span data-ttu-id="cece5-138">Parancsmag módosításai</span><span class="sxs-lookup"><span data-stu-id="cece5-138">Cmdlet changes</span></span>

### <a name="invoke-restmethod-doesnt-return-useful-info-when-no-data-is-returned-5320httpsgithubcompowershellpowershellissues5320"></a><span data-ttu-id="cece5-139">Meghívása RestMethod nem ad vissza hasznos információ, ha nem ad vissza.</span><span class="sxs-lookup"><span data-stu-id="cece5-139">Invoke-RestMethod doesn't return useful info when no data is returned.</span></span> [<span data-ttu-id="cece5-140">#5320</span><span class="sxs-lookup"><span data-stu-id="cece5-140">#5320</span></span>](https://github.com/PowerShell/PowerShell/issues/5320)

<span data-ttu-id="cece5-141">Ha egy API-t csak adja vissza `null`, Invoke-RestMethod szerializálása volt ez a karakterlánc `"null"` helyett `$null`.</span><span class="sxs-lookup"><span data-stu-id="cece5-141">When an API returns just `null`, Invoke-RestMethod was serializing this as the string `"null"` instead of `$null`.</span></span> <span data-ttu-id="cece5-142">Ez a változás javítja a logika `Invoke-RestMethod` megfelelően szerializálni az egyetlen érvényes érték JSON `null` szöveges `$null`.</span><span class="sxs-lookup"><span data-stu-id="cece5-142">This change fixes the logic in `Invoke-RestMethod` to properly serialize a valid single value JSON `null` literal as `$null`.</span></span>

### <a name="remove--computername-from--computer-cmdlets-5277httpsgithubcompowershellpowershellissues5277"></a><span data-ttu-id="cece5-143">Távolítsa el `-ComputerName` a `*-Computer` parancsmagok [#5277](https://github.com/PowerShell/PowerShell/issues/5277)</span><span class="sxs-lookup"><span data-stu-id="cece5-143">Remove `-ComputerName` from `*-Computer` cmdlets [#5277](https://github.com/PowerShell/PowerShell/issues/5277)</span></span>

<span data-ttu-id="cece5-144">RPC-táveléréssel CoreFX (különösen a nem Windows platformokon) és a egy egységes távelérése a PowerShellben, biztosítva a problémák miatt a `-ComputerName` paraméter el lett távolítva a `\*-Computer` parancsmagok.</span><span class="sxs-lookup"><span data-stu-id="cece5-144">Due to issues with RPC remoting in CoreFX (particularly on non-Windows platforms) and ensuring a consistent remoting experience in PowerShell, the `-ComputerName` parameter was removed from the `\*-Computer` cmdlets.</span></span> <span data-ttu-id="cece5-145">Használat `Invoke-Command` inkább távolról végrehajtani a parancsmagok segítségével is.</span><span class="sxs-lookup"><span data-stu-id="cece5-145">Use `Invoke-Command` instead as the way to execute cmdlets remotely.</span></span>

### <a name="remove--computername-from--service-cmdlets-5090httpsgithubcompowershellpowershellissues5094"></a><span data-ttu-id="cece5-146">Távolítsa el `-ComputerName` a `*-Service` parancsmagok [#5090](https://github.com/PowerShell/PowerShell/issues/5094)</span><span class="sxs-lookup"><span data-stu-id="cece5-146">Remove `-ComputerName` from `*-Service` cmdlets [#5090](https://github.com/PowerShell/PowerShell/issues/5094)</span></span>

<span data-ttu-id="cece5-147">Annak érdekében, hogy PSRP, konzisztens használatát javasoljuk a `-ComputerName` paraméter el lett távolítva `*-Service` parancsmagok.</span><span class="sxs-lookup"><span data-stu-id="cece5-147">In order to encourage the consistent use of PSRP, the `-ComputerName` parameter was removed from `*-Service` cmdlets.</span></span>

### <a name="fix-get-item--literalpath-ab-if-ab-doesnt-actually-exist-to-return-error-5197httpsgithubcompowershellpowershellissues5197"></a><span data-ttu-id="cece5-148">Javítsa ki `Get-Item -LiteralPath a*b` Ha `a*b` ténylegesen nem létezik, hibaüzenetet ad vissza [#5197](https://github.com/PowerShell/PowerShell/issues/5197)</span><span class="sxs-lookup"><span data-stu-id="cece5-148">Fix `Get-Item -LiteralPath a*b` if `a*b` doesn't actually exist to return error [#5197](https://github.com/PowerShell/PowerShell/issues/5197)</span></span>

<span data-ttu-id="cece5-149">Korábban a `-LiteralPath` helyettesítő karakter a megadott szeretné kezelni, azonos `-Path` , és ha a helyettesítő karakter található fájlokat, a lenne csendes kilép.</span><span class="sxs-lookup"><span data-stu-id="cece5-149">Previously, `-LiteralPath` given a wildcard would treat it the same as `-Path` and if the wildcard found no files, it would silently exit.</span></span> <span data-ttu-id="cece5-150">Megfelelő viselkedését kell lennie, amely `-LiteralPath` egy egyszerű érték, ha a fájl nem létezik, hibát kell végrehajtania.</span><span class="sxs-lookup"><span data-stu-id="cece5-150">Correct behavior should be that `-LiteralPath` is literal so if the file doesn't exist, it should error.</span></span> <span data-ttu-id="cece5-151">Változás az, hogy kezelje a helyettesítő karakterek használják `-Literal` szerint szövegkonstans.</span><span class="sxs-lookup"><span data-stu-id="cece5-151">Change is to treat wildcards used with `-Literal` as literal.</span></span>

### <a name="import-csv-should-apply-pstypenames-upon-import-when-type-information-is-present-in-the-csv-5134httpsgithubcompowershellpowershellissues5134"></a><span data-ttu-id="cece5-152">`Import-Csv` a alkalmazni kell `PSTypeNames` típussal kapcsolatos információk esetén a Megosztott fürtköteten importálását követően [#5134](https://github.com/PowerShell/PowerShell/issues/5134)</span><span class="sxs-lookup"><span data-stu-id="cece5-152">`Import-Csv` should apply `PSTypeNames` upon import when type information is present in the CSV [#5134](https://github.com/PowerShell/PowerShell/issues/5134)</span></span>

<span data-ttu-id="cece5-153">Korábban az exportált objektumokat használatával `Export-CSV` a `TypeInformation` együtt importálja `ConvertFrom-Csv` nem lett megőrizve a típussal kapcsolatos információk.</span><span class="sxs-lookup"><span data-stu-id="cece5-153">Previously, objects exported using `Export-CSV` with `TypeInformation` imported with `ConvertFrom-Csv` were not retaining the type information.</span></span> <span data-ttu-id="cece5-154">Ez a módosítás hozzáadja a típussal kapcsolatos információk a `PSTypeNames` tag ha rendelkezésre áll a CSV-fájlból.</span><span class="sxs-lookup"><span data-stu-id="cece5-154">This change adds the type information to `PSTypeNames` member if available from the CSV file.</span></span>

### <a name="-notypeinformation-should-be-default-on-export-csv-5131httpsgithubcompowershellpowershellissues5131"></a><span data-ttu-id="cece5-155">`-NoTypeInformation` alapértelmezett kell lennie a `Export-Csv` [#5131](https://github.com/PowerShell/PowerShell/issues/5131)</span><span class="sxs-lookup"><span data-stu-id="cece5-155">`-NoTypeInformation` should be default on `Export-Csv` [#5131](https://github.com/PowerShell/PowerShell/issues/5131)</span></span>

<span data-ttu-id="cece5-156">Ezt a módosítást hajtottak végre a alapértelmezett viselkedését, az ügyfélvisszajelzésekre `Export-CSV` típus információval.</span><span class="sxs-lookup"><span data-stu-id="cece5-156">This change was made to address customer feedback on the default behavior of `Export-CSV` to include type information.</span></span>

<span data-ttu-id="cece5-157">Korábban a parancsmag lenne a kimeneti megjegyzést, az első sor tartalmazza az objektum nevét.</span><span class="sxs-lookup"><span data-stu-id="cece5-157">Previously, the cmdlet would output a comment as the first line containing the type name of the object.</span></span> <span data-ttu-id="cece5-158">A módosítás, akkor nem tudja értelmezni a legtöbb eszközök letiltásához ez alapértelmezés szerint.</span><span class="sxs-lookup"><span data-stu-id="cece5-158">The change is to suppress this by default as it's not understood by most tools.</span></span> <span data-ttu-id="cece5-159">Használat `-IncludeTypeInformation` megőrzi a korábbi működése.</span><span class="sxs-lookup"><span data-stu-id="cece5-159">Use `-IncludeTypeInformation` to retain the previous behavior.</span></span>

### <a name="web-cmdlets-should-warn-when--credential-is-sent-over-unencrypted-connections-5112httpsgithubcompowershellpowershellissues5112"></a><span data-ttu-id="cece5-160">Webes parancsmagok figyelmeztetnek, ha `-Credential` titkosítatlan kapcsolaton keresztül zajlik [#5112](https://github.com/PowerShell/PowerShell/issues/5112)</span><span class="sxs-lookup"><span data-stu-id="cece5-160">Web Cmdlets should warn when `-Credential` is sent over unencrypted connections [#5112](https://github.com/PowerShell/PowerShell/issues/5112)</span></span>

<span data-ttu-id="cece5-161">HTTP használata esetén a tartalmat, beleértve a jelszavak tiszta szövegként érkeznek.</span><span class="sxs-lookup"><span data-stu-id="cece5-161">When using HTTP, content including passwords are sent as clear-text.</span></span> <span data-ttu-id="cece5-162">Ez a változás, hogy nem engedélyezze ez alapértelmezés szerint, és hibát adhat vissza, ha az nem biztonságos módon, hogy átadta a hitelesítő adatok.</span><span class="sxs-lookup"><span data-stu-id="cece5-162">This change is to not allow this by default and return an error if credentials are being passed in an insecure manner.</span></span> <span data-ttu-id="cece5-163">Felhasználók használatával elkerülheti ezt a `-AllowUnencryptedAuthentication` váltani.</span><span class="sxs-lookup"><span data-stu-id="cece5-163">Users can bypass this by using the `-AllowUnencryptedAuthentication` switch.</span></span>

## <a name="api-changes"></a><span data-ttu-id="cece5-164">API-módosítás</span><span class="sxs-lookup"><span data-stu-id="cece5-164">API changes</span></span>

### <a name="remove-addtypecommandbase-class-5407httpsgithubcompowershellpowershellissues5407"></a><span data-ttu-id="cece5-165">Távolítsa el `AddTypeCommandBase` osztály [#5407](https://github.com/PowerShell/PowerShell/issues/5407)</span><span class="sxs-lookup"><span data-stu-id="cece5-165">Remove `AddTypeCommandBase` class [#5407](https://github.com/PowerShell/PowerShell/issues/5407)</span></span>

<span data-ttu-id="cece5-166">A `AddTypeCommandBase` osztály el lett távolítva `Add-Type` teljesítmény javítása érdekében.</span><span class="sxs-lookup"><span data-stu-id="cece5-166">The `AddTypeCommandBase` class was removed from `Add-Type` to improve performance.</span></span> <span data-ttu-id="cece5-167">Ez az osztály csak az Add-Type parancsmagot használja, és a felhasználók nem érinti.</span><span class="sxs-lookup"><span data-stu-id="cece5-167">This class is only used by the Add-Type cmdlet and should not impact users.</span></span>

### <a name="unify-cmdlets-with-parameter--encoding-to-be-of-type-systemtextencoding-5080httpsgithubcompowershellpowershellissues5080"></a><span data-ttu-id="cece5-168">Használja őket egységes előtérrendszerként paraméterrel parancsmagok `-Encoding` típusú `System.Text.Encoding` [#5080](https://github.com/PowerShell/PowerShell/issues/5080)</span><span class="sxs-lookup"><span data-stu-id="cece5-168">Unify cmdlets with parameter `-Encoding` to be of type `System.Text.Encoding` [#5080](https://github.com/PowerShell/PowerShell/issues/5080)</span></span>

<span data-ttu-id="cece5-169">A `-Encoding` érték `Byte` a fájlrendszer-szolgáltató parancsmagjai el lett távolítva.</span><span class="sxs-lookup"><span data-stu-id="cece5-169">The `-Encoding` value `Byte` has been removed from the filesystem provider cmdlets.</span></span> <span data-ttu-id="cece5-170">Egy új paraméter `-AsByteStream`, most azt adhatja meg, hogy egy bájt stream szükség, mint bemenet vagy az, hogy a kimenet a stream bájt.</span><span class="sxs-lookup"><span data-stu-id="cece5-170">A new parameter, `-AsByteStream`, is now used to specify that a byte stream is required as input or that the output is a stream of bytes.</span></span>

### <a name="add-better-error-message-for-empty-and-null--uformat-parameter-5055httpsgithubcompowershellpowershellissues5055"></a><span data-ttu-id="cece5-171">Jobb hibaüzenet üres és null hozzáadása `-UFormat` paraméter [#5055](https://github.com/PowerShell/PowerShell/issues/5055)</span><span class="sxs-lookup"><span data-stu-id="cece5-171">Add better error message for empty and null `-UFormat` parameter [#5055](https://github.com/PowerShell/PowerShell/issues/5055)</span></span>

<span data-ttu-id="cece5-172">Korábban, ha átadja egy üres formázó karakterlánc `-UFormat`, unhelpful hibaüzenet jelent.</span><span class="sxs-lookup"><span data-stu-id="cece5-172">Previously, when passing an empty format string to `-UFormat`, an unhelpful error message would appear.</span></span> <span data-ttu-id="cece5-173">A kifejezőbb hiba lett hozzáadva.</span><span class="sxs-lookup"><span data-stu-id="cece5-173">A more descriptive error has been added.</span></span>

### <a name="clean-up-console-code-4995httpsgithubcompowershellpowershellissues4995"></a><span data-ttu-id="cece5-174">Távolítsa el a konzol kód [#4995](https://github.com/PowerShell/PowerShell/issues/4995)</span><span class="sxs-lookup"><span data-stu-id="cece5-174">Clean up console code [#4995](https://github.com/PowerShell/PowerShell/issues/4995)</span></span>

<span data-ttu-id="cece5-175">A következő szolgáltatások eltávolítása nem támogatott a PowerShell Core, és nem is léteznek régi okokból Windows PowerShell-támogatás hozzáadása tervezzük: `-psconsolefile` kapcsoló és a kódot, `-importsystemmodules` kapcsoló és a kódot, és a betűtípus módosítása a kódot.</span><span class="sxs-lookup"><span data-stu-id="cece5-175">The following features were removed as they are not supported in PowerShell Core, and there are no plans to add support as they exist for legacy reasons for Windows PowerShell: `-psconsolefile` switch and code, `-importsystemmodules` switch and code, and font changing code.</span></span>

### <a name="removed-runspaceconfiguration-support-4942httpsgithubcompowershellpowershellissues4942"></a><span data-ttu-id="cece5-176">Eltávolított `RunspaceConfiguration` támogatja [#4942](https://github.com/PowerShell/PowerShell/issues/4942)</span><span class="sxs-lookup"><span data-stu-id="cece5-176">Removed `RunspaceConfiguration` support [#4942](https://github.com/PowerShell/PowerShell/issues/4942)</span></span>

<span data-ttu-id="cece5-177">Korábban a programozott módon a PowerShell futási térben létrehozásakor az API-val is használhat a régebbi [ `RunspaceConfiguration` ] [ runspaceconfig] és az újabb [ `InitialSessionState` ] [ iss].</span><span class="sxs-lookup"><span data-stu-id="cece5-177">Previously, when creating a PowerShell runspace programmatically using the API you could use the legacy [`RunspaceConfiguration`][runspaceconfig] or the newer [`InitialSessionState`][iss].</span></span> <span data-ttu-id="cece5-178">Ez a változás nem támogatja az `RunspaceConfiguration` , és csak támogatja `InitialSessionState`.</span><span class="sxs-lookup"><span data-stu-id="cece5-178">This change removed support for `RunspaceConfiguration` and only supports `InitialSessionState`.</span></span>

[runspaceconfig]: https://docs.microsoft.com/dotnet/api/system.management.automation.runspaces.runspaceconfiguration
[iss]: https://docs.microsoft.com/dotnet/api/system.management.automation.runspaces.initialsessionstate

### <a name="commandinvocationintrinsicsinvokescript-bind-arguments-to-input-instead-of-args-4923httpsgithubcompowershellpowershellissues4923"></a><span data-ttu-id="cece5-179">`CommandInvocationIntrinsics.InvokeScript` argumenty kötési `$input` helyett `$args` [#4923](https://github.com/PowerShell/PowerShell/issues/4923)</span><span class="sxs-lookup"><span data-stu-id="cece5-179">`CommandInvocationIntrinsics.InvokeScript` bind arguments to `$input` instead of `$args` [#4923](https://github.com/PowerShell/PowerShell/issues/4923)</span></span>

<span data-ttu-id="cece5-180">Egy paraméter helytelen pozícióját az átadott argumentum, helyett bemeneti argumentum eredményezett.</span><span class="sxs-lookup"><span data-stu-id="cece5-180">An incorrect position of a parameter resulted in the args passed as input instead of as args.</span></span>

### <a name="remove-unsupported--showwindow-switch-from-get-help-4903httpsgithubcompowershellpowershellissues4903"></a><span data-ttu-id="cece5-181">Távolítsa el a nem támogatott `-showwindow` átállás `Get-Help` [#4903](https://github.com/PowerShell/PowerShell/issues/4903)</span><span class="sxs-lookup"><span data-stu-id="cece5-181">Remove unsupported `-showwindow` switch from `Get-Help` [#4903](https://github.com/PowerShell/PowerShell/issues/4903)</span></span>

<span data-ttu-id="cece5-182">`-showwindow` WPF-, amely nem támogatott coreclr-nek a támaszkodik.</span><span class="sxs-lookup"><span data-stu-id="cece5-182">`-showwindow` relies on WPF, which is not supported on CoreCLR.</span></span>

### <a name="allow--to-be-used-in-registry-path-for-remove-item-4866httpsgithubcompowershellpowershellissues4866"></a><span data-ttu-id="cece5-183">Lehetővé teszi \* beállításjegyzékbeli elérési út a használandó `Remove-Item` [#4866](https://github.com/PowerShell/PowerShell/issues/4866)</span><span class="sxs-lookup"><span data-stu-id="cece5-183">Allow \* to be used in registry path for `Remove-Item` [#4866](https://github.com/PowerShell/PowerShell/issues/4866)</span></span>

<span data-ttu-id="cece5-184">Korábban a `-LiteralPath` helyettesítő karakter a megadott szeretné kezelni, azonos `-Path` , és ha a helyettesítő karakter található fájlokat, a lenne csendes kilép.</span><span class="sxs-lookup"><span data-stu-id="cece5-184">Previously, `-LiteralPath` given a wildcard would treat it the same as `-Path` and if the wildcard found no files, it would silently exit.</span></span> <span data-ttu-id="cece5-185">Megfelelő viselkedését kell lennie, amely `-LiteralPath` egy egyszerű érték, ha a fájl nem létezik, hibát kell végrehajtania.</span><span class="sxs-lookup"><span data-stu-id="cece5-185">Correct behavior should be that `-LiteralPath` is literal so if the file doesn't exist, it should error.</span></span> <span data-ttu-id="cece5-186">Változás az, hogy kezelje a helyettesítő karakterek használják `-Literal` szerint szövegkonstans.</span><span class="sxs-lookup"><span data-stu-id="cece5-186">Change is to treat wildcards used with `-Literal` as literal.</span></span>

### <a name="fix-set-service-failing-test-4802httpsgithubcompowershellpowershellissues4802"></a><span data-ttu-id="cece5-187">Javítsa ki `Set-Service` sikertelen teszt [#4802](https://github.com/PowerShell/PowerShell/issues/4802)</span><span class="sxs-lookup"><span data-stu-id="cece5-187">Fix `Set-Service` failing test [#4802](https://github.com/PowerShell/PowerShell/issues/4802)</span></span>

<span data-ttu-id="cece5-188">Korábban Ha `New-Service -StartupType foo` használták, `foo` figyelmen kívül lett hagyva, és a szolgáltatás néhány alapértelmezett indítási típus lett létrehozva.</span><span class="sxs-lookup"><span data-stu-id="cece5-188">Previously, if `New-Service -StartupType foo` was used, `foo` was ignored and the service was created with some default startup type.</span></span> <span data-ttu-id="cece5-189">Ez a változás, hogy explicit módon throw egy érvénytelen indítási típus hiba.</span><span class="sxs-lookup"><span data-stu-id="cece5-189">This change is to explicitly throw an error for an invalid startup type.</span></span>

### <a name="rename-isosx-to-ismacos-4700httpsgithubcompowershellpowershellissues4700"></a><span data-ttu-id="cece5-190">Nevezze át `$IsOSX` való `$IsMacOS` [#4700](https://github.com/PowerShell/PowerShell/issues/4700)</span><span class="sxs-lookup"><span data-stu-id="cece5-190">Rename `$IsOSX` to `$IsMacOS` [#4700](https://github.com/PowerShell/PowerShell/issues/4700)</span></span>

<span data-ttu-id="cece5-191">A PowerShellben elnevezési kell konzisztensek legyenek a kiosztási és felelnek meg az Apple OSX helyett macOS használatát.</span><span class="sxs-lookup"><span data-stu-id="cece5-191">The naming in PowerShell should be consistent with our naming and conform to Apple's use of macOS instead of OSX.</span></span> <span data-ttu-id="cece5-192">Azonban az olvashatóság érdekében és következetesen azt tartózkodó Pascal a kis-és nagybetűhasználatot.</span><span class="sxs-lookup"><span data-stu-id="cece5-192">However, for readability and consistently we are staying with Pascal casing.</span></span>

### <a name="make-error-message-consistent-when-invalid-script-is-passed-to--file-better-error-when-passed-ambiguous-argument-4573httpsgithubcompowershellpowershellissues4573"></a><span data-ttu-id="cece5-193">Győződjön meg arról, hibaüzenet jelenik meg konzisztens amikor átadott érvénytelen parancsprogram-fájlt, a hiba, ha a nem egyértelmű argumentum jobb [#4573](https://github.com/PowerShell/PowerShell/issues/4573)</span><span class="sxs-lookup"><span data-stu-id="cece5-193">Make error message consistent when invalid script is passed to -File, better error when passed ambiguous argument [#4573](https://github.com/PowerShell/PowerShell/issues/4573)</span></span>

<span data-ttu-id="cece5-194">Módosítsa a kilépési kódot `pwsh.exe` igazodva Unix konvenciók</span><span class="sxs-lookup"><span data-stu-id="cece5-194">Change the exit codes of `pwsh.exe` to align with Unix conventions</span></span>

### <a name="removal-of-localaccount-and-cmdlets-from--diagnostics-modules-4302httpsgithubcompowershellpowershellissues4302-4303httpsgithubcompowershellpowershellissues4303"></a><span data-ttu-id="cece5-195">Eltávolításának `LocalAccount` és parancsmagjait `Diagnostics` modulok.</span><span class="sxs-lookup"><span data-stu-id="cece5-195">Removal of `LocalAccount` and cmdlets from  `Diagnostics` modules.</span></span> <span data-ttu-id="cece5-196">[#4302](https://github.com/PowerShell/PowerShell/issues/4302) [#4303](https://github.com/PowerShell/PowerShell/issues/4303)</span><span class="sxs-lookup"><span data-stu-id="cece5-196">[#4302](https://github.com/PowerShell/PowerShell/issues/4302) [#4303](https://github.com/PowerShell/PowerShell/issues/4303)</span></span>

<span data-ttu-id="cece5-197">Nem támogatott API-kat, mert a `LocalAccounts` modul és a `Counter` parancsmagok a a `Diagnostics` modul el lettek távolítva, amíg nem jobb megoldás található.</span><span class="sxs-lookup"><span data-stu-id="cece5-197">Due to unsupported APIs, the `LocalAccounts` module and the `Counter` cmdlets in the `Diagnostics` module were removed until a better solution is found.</span></span>

### <a name="executing-powershell-script-with-bool-parameter-does-not-work-4036httpsgithubcompowershellpowershellissues4036"></a><span data-ttu-id="cece5-198">Logikai paraméter a powershell-parancsprogram futtatása nem működik [#4036](https://github.com/PowerShell/PowerShell/issues/4036)</span><span class="sxs-lookup"><span data-stu-id="cece5-198">Executing powershell script with bool parameter does not work [#4036](https://github.com/PowerShell/PowerShell/issues/4036)</span></span>

<span data-ttu-id="cece5-199">Korábban, a powershell.exe használatával (mostantól `pwsh.exe`) végrehajtásához egy PowerShell szkriptet az `-File` semmilyen módon nem lehet átadni $true megadott/$false paraméter értékeként.</span><span class="sxs-lookup"><span data-stu-id="cece5-199">Previously, using powershell.exe (now `pwsh.exe`) to execute a PowerShell script using `-File` provided no way to pass $true/$false as parameter values.</span></span> <span data-ttu-id="cece5-200">$True támogatása/elemzett értékeket a paraméterekhez $false hozzá lett adva.</span><span class="sxs-lookup"><span data-stu-id="cece5-200">Support for $true/$false as parsed values to parameters was added.</span></span> <span data-ttu-id="cece5-201">Kapcsoló értékeket is támogatottak, ahogy jelenleg dokumentált szintaxis nem működik.</span><span class="sxs-lookup"><span data-stu-id="cece5-201">Switch values are also supported as currently documented syntax doesn't work.</span></span>

### <a name="remove-clrversion-property-from-psversiontable-4027httpsgithubcompowershellpowershellissues4027"></a><span data-ttu-id="cece5-202">Távolítsa el `ClrVersion` tulajdonságot `$PSVersionTable` [#4027](https://github.com/PowerShell/PowerShell/issues/4027)</span><span class="sxs-lookup"><span data-stu-id="cece5-202">Remove `ClrVersion` property from `$PSVersionTable` [#4027](https://github.com/PowerShell/PowerShell/issues/4027)</span></span>

<span data-ttu-id="cece5-203">A `ClrVersion` tulajdonságát `$PSVersionTable` van coreclr-nek nem használható, a végfelhasználók kell nem használja ezt az értéket a kompatibilitás meghatározása.</span><span class="sxs-lookup"><span data-stu-id="cece5-203">The `ClrVersion` property of `$PSVersionTable` is not useful with CoreCLR, end users should not be using that value to determine compatibility.</span></span>

### <a name="change-positional-parameter-for-powershellexe-from--command-to--file-4019httpsgithubcompowershellpowershellissues4019"></a><span data-ttu-id="cece5-204">Módosítsa a Helyzetbeállító paramétere `powershell.exe` a `-Command` való `-File` [#4019](https://github.com/PowerShell/PowerShell/issues/4019)</span><span class="sxs-lookup"><span data-stu-id="cece5-204">Change positional parameter for `powershell.exe` from `-Command` to `-File` [#4019](https://github.com/PowerShell/PowerShell/issues/4019)</span></span>

<span data-ttu-id="cece5-205">A nem Windows platformokon shebangje határoz meg PowerShell használatának engedélyezése.</span><span class="sxs-lookup"><span data-stu-id="cece5-205">Enable shebang use of PowerShell on non-Windows platforms.</span></span> <span data-ttu-id="cece5-206">Ez azt jelenti, hogy a Unix-alapú rendszerek esetében szeretné meghívni a PowerShell parancsfájl végrehajtható teheti automatikusan ahelyett, hogy explicit módon meghívása `pwsh`.</span><span class="sxs-lookup"><span data-stu-id="cece5-206">This means on Unix based systems, you can make a script executable that would invoke PowerShell automatically rather than explicitly invoking `pwsh`.</span></span> <span data-ttu-id="cece5-207">Ez azt is jelenti, hogy most már elvégezhető többek között `powershell foo.ps1` vagy `powershell fooScript` megadása nélkül `-File`.</span><span class="sxs-lookup"><span data-stu-id="cece5-207">This also means that you can now do things like `powershell foo.ps1` or `powershell fooScript` without specifying `-File`.</span></span> <span data-ttu-id="cece5-208">Azonban ez a változás most megköveteli, hogy Ön kifejezetten megad `-c` vagy `-Command` többek között a tett kísérlet során `powershell.exe Get-Command`.</span><span class="sxs-lookup"><span data-stu-id="cece5-208">However, this change now requires that you explicitly specify `-c` or `-Command` when trying to do things like `powershell.exe Get-Command`.</span></span>

### <a name="implement-unicode-escape-parsing-3958httpsgithubcompowershellpowershellissues3958"></a><span data-ttu-id="cece5-209">Unicode escape-elemzés megvalósítása [#3958](https://github.com/PowerShell/PowerShell/issues/3958)</span><span class="sxs-lookup"><span data-stu-id="cece5-209">Implement Unicode escape parsing [#3958](https://github.com/PowerShell/PowerShell/issues/3958)</span></span>

<span data-ttu-id="cece5-210">`` `u#### `` vagy `` `u{####} `` megfelelő Unicode-karaktert alakítja át.</span><span class="sxs-lookup"><span data-stu-id="cece5-210">`` `u#### `` or `` `u{####} `` is converted to the corresponding Unicode character.</span></span> <span data-ttu-id="cece5-211">A kimenetben szövegkonstans `` `u ``, a használni kívánt szintaxiskiemelést escape: ``` ``u ```.</span><span class="sxs-lookup"><span data-stu-id="cece5-211">To output a literal `` `u ``, escape the backtick: ``` ``u ```.</span></span>

### <a name="change-new-modulemanifest-encoding-to-utf8nobom-on-non-windows-platforms-3940httpsgithubcompowershellpowershellissues3940"></a><span data-ttu-id="cece5-212">Változás `New-ModuleManifest` kódolási `UTF8NoBOM` nem Windows platformokon [#3940](https://github.com/PowerShell/PowerShell/issues/3940)</span><span class="sxs-lookup"><span data-stu-id="cece5-212">Change `New-ModuleManifest` encoding to `UTF8NoBOM` on non-Windows platforms [#3940](https://github.com/PowerShell/PowerShell/issues/3940)</span></span>

<span data-ttu-id="cece5-213">Korábban a `New-ModuleManifest` psd1 kiterjesztésű jegyzékek létrehoz az UTF-16-AJ, Linux rendszerű eszközök kerülni létrehozásával.</span><span class="sxs-lookup"><span data-stu-id="cece5-213">Previously, `New-ModuleManifest` creates psd1 manifests in UTF-16 with BOM, creating a problem for Linux tools.</span></span> <span data-ttu-id="cece5-214">Ez használhatatlanná tévő változás módosítja a kódolását `New-ModuleManifest` UTF (nincs AJ) kell a nem Windows platformokon.</span><span class="sxs-lookup"><span data-stu-id="cece5-214">This breaking change changes the encoding of `New-ModuleManifest` to be UTF (no BOM) in non-Windows platforms.</span></span>

### <a name="prevent-get-childitem-from-recursing-into-symlinks-1875-3780httpsgithubcompowershellpowershellissues3780"></a><span data-ttu-id="cece5-215">Megakadályozása `Get-ChildItem` származó be symlinks recursing (#1875).</span><span class="sxs-lookup"><span data-stu-id="cece5-215">Prevent `Get-ChildItem` from recursing into symlinks (#1875).</span></span> [<span data-ttu-id="cece5-216">#3780</span><span class="sxs-lookup"><span data-stu-id="cece5-216">#3780</span></span>](https://github.com/PowerShell/PowerShell/issues/3780)

<span data-ttu-id="cece5-217">Ez a változás csökkenti a `Get-ChildItem` Unix megfelelően további `ls -r` és a Windows `dir /s` natív parancsokat.</span><span class="sxs-lookup"><span data-stu-id="cece5-217">This change brings `Get-ChildItem` more in line with the Unix `ls -r` and the Windows `dir /s` native commands.</span></span> <span data-ttu-id="cece5-218">Az említett parancsokat, mint például a parancsmag jeleníti meg a szimbolikus hivatkozásokat a rekurzió során találhatók címtárak, de nem recurse be őket.</span><span class="sxs-lookup"><span data-stu-id="cece5-218">Like the mentioned commands, the cmdlet displays symbolic links to directories found during recursion, but does not recurse into them.</span></span>

### <a name="fix-get-content--delimiter-to-not-include-the-delimiter-in-the-returned-lines-3706httpsgithubcompowershellpowershellissues3706"></a><span data-ttu-id="cece5-219">Javítsa ki `Get-Content -Delimiter` nem tartalmazza a kivonni kívánt a visszaadott sorok [#3706](https://github.com/PowerShell/PowerShell/issues/3706)</span><span class="sxs-lookup"><span data-stu-id="cece5-219">Fix `Get-Content -Delimiter` to not include the delimiter in the returned lines [#3706](https://github.com/PowerShell/PowerShell/issues/3706)</span></span>

<span data-ttu-id="cece5-220">Korábban, a kimeneti használata során `Get-Content -Delimiter` inkonzisztens és kényelmetlen lehet, ahogy ez szükséges az elválasztó karakter eltávolítása az adatok további feldolgozás céljából.</span><span class="sxs-lookup"><span data-stu-id="cece5-220">Previously, the output while using `Get-Content -Delimiter` was inconsistent and inconvenient as it required further processing of the data to remove the delimiter.</span></span> <span data-ttu-id="cece5-221">Ez a változás a elválasztó eltávolítja a visszaadott sorok.</span><span class="sxs-lookup"><span data-stu-id="cece5-221">This change removes the delimiter in returned lines.</span></span>

### <a name="implement-format-hex-in-c-3320httpsgithubcompowershellpowershellissues3320"></a><span data-ttu-id="cece5-222">Hexadecimális formátumban, a megvalósítása C# [#3320](https://github.com/PowerShell/PowerShell/issues/3320)</span><span class="sxs-lookup"><span data-stu-id="cece5-222">Implement Format-Hex in C# [#3320](https://github.com/PowerShell/PowerShell/issues/3320)</span></span>

<span data-ttu-id="cece5-223">A `-Raw` paraméter már "műveletvégzés" (abban, hogy ezt nem semmi sem).</span><span class="sxs-lookup"><span data-stu-id="cece5-223">The `-Raw` parameter is now a "no-op" (in that it does nothing).</span></span> <span data-ttu-id="cece5-224">Módosítástól minden, a kimenet jelenik meg, amely tartalmazza az összes ehhez a típushoz a bájtok számok igaz reprezentációját (Mi a `-Raw` paraméter hivatalosan ennek során ez a módosítás előtt).</span><span class="sxs-lookup"><span data-stu-id="cece5-224">Going forward all of the output will be displayed with a true representation of numbers that includes all of the bytes for its type (what the `-Raw` parameter was formally doing prior to this change).</span></span>

### <a name="powershell-as-a-default-shell-doesnt-work-with-script-command-3319httpsgithubcompowershellpowershellissues3319"></a><span data-ttu-id="cece5-225">Egy alapértelmezett rendszerhéját, PowerShell-parancsprogram-utasítás nem működik [#3319](https://github.com/PowerShell/PowerShell/issues/3319)</span><span class="sxs-lookup"><span data-stu-id="cece5-225">PowerShell as a default shell doesn't work with script command [#3319](https://github.com/PowerShell/PowerShell/issues/3319)</span></span>

<span data-ttu-id="cece5-226">A Unix és a egy fogadására parancsikonja egyezmény `-i` az interaktív shell és a számos eszköz Ez a viselkedés várható (`script` például és beállítása a PowerShell, az alapértelmezett rendszerhéját) és a rendszerhéj-meghívja a `-i` váltson.</span><span class="sxs-lookup"><span data-stu-id="cece5-226">On Unix, it is a convention for shells to accept `-i` for an interactive shell and many tools expect this behavior (`script` for example, and when setting PowerShell as the default shell) and calls the shell with the `-i` switch.</span></span> <span data-ttu-id="cece5-227">Ez a változás, amely a megsérti `-i` korábban volt használható rövid aktuális megfelelően `-inputformat`, így kell lennie `-in`.</span><span class="sxs-lookup"><span data-stu-id="cece5-227">This change is breaking in that `-i` previously could be used as short hand to match `-inputformat`, which now needs to be `-in`.</span></span>

### <a name="typo-fix-in-get-computerinfo-property-name-3167httpsgithubcompowershellpowershellissues3167"></a><span data-ttu-id="cece5-228">Elírta javítása a Get-ComputerInfo tulajdonságnév [#3167](https://github.com/PowerShell/PowerShell/issues/3167)</span><span class="sxs-lookup"><span data-stu-id="cece5-228">Typo fix in Get-ComputerInfo property name [#3167](https://github.com/PowerShell/PowerShell/issues/3167)</span></span>

<span data-ttu-id="cece5-229">`BiosSerialNumber` lett írva `BiosSeralNumber` és helyesen van beállítva.</span><span class="sxs-lookup"><span data-stu-id="cece5-229">`BiosSerialNumber` was misspelled as `BiosSeralNumber` and has been changed to the correct spelling.</span></span>

### <a name="add-get-stringhash-and-get-filehash-cmdlets-3024httpsgithubcompowershellpowershellissues3024"></a><span data-ttu-id="cece5-230">Adjon hozzá `Get-StringHash` és `Get-FileHash` parancsmagok [#3024](https://github.com/PowerShell/PowerShell/issues/3024)</span><span class="sxs-lookup"><span data-stu-id="cece5-230">Add `Get-StringHash` and `Get-FileHash` cmdlets [#3024](https://github.com/PowerShell/PowerShell/issues/3024)</span></span>

<span data-ttu-id="cece5-231">Ez a változás, hogy néhány kivonatoló algoritmusok CoreFX által nem támogatott, ezért azok már nem érhetők el:</span><span class="sxs-lookup"><span data-stu-id="cece5-231">This change is that some hash algorithms are not supported by CoreFX, therefore they are no longer available:</span></span>

- `MACTripleDES`
- `RIPEMD160`

### <a name="add-validation-on-get--cmdlets-where-passing-null-returns-all-objects-instead-of-error-2672httpsgithubcompowershellpowershellissues2672"></a><span data-ttu-id="cece5-232">Ellenőrzés bekapcsolása `Get-*` parancsmagok, ahol passing $null adja vissza a hiba helyett az összes objektum [#2672](https://github.com/PowerShell/PowerShell/issues/2672)</span><span class="sxs-lookup"><span data-stu-id="cece5-232">Add validation on `Get-*` cmdlets where passing $null returns all objects instead of error [#2672](https://github.com/PowerShell/PowerShell/issues/2672)</span></span>

<span data-ttu-id="cece5-233">Átmenő `$null` valamelyik a következő egyelőre hibát jelez:</span><span class="sxs-lookup"><span data-stu-id="cece5-233">Passing `$null` to any of the following now throws an error:</span></span>

- `Get-Credential -UserName`
- `Get-Event -SourceIdentifier`
- `Get-EventSubscriber -SourceIdentifier`
- `Get-Help -Name`
- `Get-PSBreakpoint -Script`
- `Get-PSProvider -PSProvider`
- `Get-PSSessionConfiguration -Name`
- `Get-PSSnapin -Name`
- `Get-Runspace -Name`
- `Get-RunspaceDebug -RunspaceName`
- `Get-Service -Name`
- `Get-TraceSource -Name`
- `Get-Variable -Name`
- `Get-WmiObject -Class`
- `Get-WmiObject -Property`

### <a name="add-support-w3c-extended-log-file-format-in-import-csv-2482httpsgithubcompowershellpowershellissues2482"></a><span data-ttu-id="cece5-234">Adja hozzá a W3C bővített naplófájlformátum az támogatási `Import-Csv` [#2482](https://github.com/PowerShell/PowerShell/issues/2482)</span><span class="sxs-lookup"><span data-stu-id="cece5-234">Add support W3C Extended Log File Format in `Import-Csv` [#2482](https://github.com/PowerShell/PowerShell/issues/2482)</span></span>

<span data-ttu-id="cece5-235">Korábban a `Import-Csv` parancsmag nem használható közvetlenül importálhat a W3C bővített naplóformátumban naplófájlokat, és további művelet lenne szükséges.</span><span class="sxs-lookup"><span data-stu-id="cece5-235">Previously, the `Import-Csv` cmdlet cannot be used to directly import the log files in W3C extended log format and additional action would be required.</span></span> <span data-ttu-id="cece5-236">Ez a változás a W3C bővített naplóformátumban támogatott.</span><span class="sxs-lookup"><span data-stu-id="cece5-236">With this change, W3C extended log format is supported.</span></span>

### <a name="parameter-binding-problem-with-valuefromremainingarguments-in-ps-functions-2035httpsgithubcompowershellpowershellissues2035"></a><span data-ttu-id="cece5-237">Paraméter kötés problémájára `ValueFromRemainingArguments` a PS-függvények [#2035](https://github.com/PowerShell/PowerShell/issues/2035)</span><span class="sxs-lookup"><span data-stu-id="cece5-237">Parameter binding problem with `ValueFromRemainingArguments` in PS functions [#2035](https://github.com/PowerShell/PowerShell/issues/2035)</span></span>

<span data-ttu-id="cece5-238">`ValueFromRemainingArguments` most adja vissza az értékeket egy tömbként helyett egy érték osztályon van egy tömb.</span><span class="sxs-lookup"><span data-stu-id="cece5-238">`ValueFromRemainingArguments` now returns the values as an array instead of a single value which itself is an array.</span></span>

### <a name="buildversion-is-removed-from-psversiontable-1415httpsgithubcompowershellpowershellissues1415"></a><span data-ttu-id="cece5-239">`BuildVersion` eltávolítják az `$PSVersionTable` [#1415](https://github.com/PowerShell/PowerShell/issues/1415)</span><span class="sxs-lookup"><span data-stu-id="cece5-239">`BuildVersion` is removed from `$PSVersionTable` [#1415](https://github.com/PowerShell/PowerShell/issues/1415)</span></span>

<span data-ttu-id="cece5-240">Távolítsa el a `BuildVersion` tulajdonságot `$PSVersionTable`.</span><span class="sxs-lookup"><span data-stu-id="cece5-240">Remove the `BuildVersion` property from `$PSVersionTable`.</span></span> <span data-ttu-id="cece5-241">Ez a tulajdonság a Windows build-verziószáma kötött.</span><span class="sxs-lookup"><span data-stu-id="cece5-241">This property was tied to the Windows build version.</span></span> <span data-ttu-id="cece5-242">Ehelyett azt javasoljuk, hogy használjon `GitCommitId` a PowerShell Core pontos buildverziója lekéréséhez.</span><span class="sxs-lookup"><span data-stu-id="cece5-242">Instead, we recommend that you use `GitCommitId` to retrieve the exact build version of PowerShell Core.</span></span>

### <a name="changes-to-web-cmdlets"></a><span data-ttu-id="cece5-243">Webes parancsmagok módosításai</span><span class="sxs-lookup"><span data-stu-id="cece5-243">Changes to Web Cmdlets</span></span>

<span data-ttu-id="cece5-244">Az alapul szolgáló .NET API a webes parancsmagok értékre változott `System.Net.Http.HttpClient`.</span><span class="sxs-lookup"><span data-stu-id="cece5-244">The underlying .NET API of the Web Cmdlets has been changed to `System.Net.Http.HttpClient`.</span></span> <span data-ttu-id="cece5-245">Ez a változás üzenetcsere számos előnnyel jár.</span><span class="sxs-lookup"><span data-stu-id="cece5-245">This change provides many benefits.</span></span> <span data-ttu-id="cece5-246">Azonban ezt a módosítást, és az Internet Explorer együttműködés hiánya belül több kompatibilitástörő változásokat eredményezték `Invoke-WebRequest` és `Invoke-RestMethod`.</span><span class="sxs-lookup"><span data-stu-id="cece5-246">However, this change along with a lack of interoperability with Internet Explorer have resulted in several breaking changes within `Invoke-WebRequest` and `Invoke-RestMethod`.</span></span>

- <span data-ttu-id="cece5-247">`Invoke-WebRequest` mostantól támogatja az alapszintű HTML elemzése csak.</span><span class="sxs-lookup"><span data-stu-id="cece5-247">`Invoke-WebRequest` now supports basic HTML Parsing only.</span></span> <span data-ttu-id="cece5-248">`Invoke-WebRequest` mindig adja vissza egy `BasicHtmlWebResponseObject` objektum.</span><span class="sxs-lookup"><span data-stu-id="cece5-248">`Invoke-WebRequest` always returns a `BasicHtmlWebResponseObject` object.</span></span> <span data-ttu-id="cece5-249">A `ParsedHtml` és `Forms` tulajdonságai el lettek távolítva.</span><span class="sxs-lookup"><span data-stu-id="cece5-249">The `ParsedHtml` and `Forms` properties have been removed.</span></span>
- <span data-ttu-id="cece5-250">`BasicHtmlWebResponseObject.Headers` értékek: mostantól `String[]` helyett `String`.</span><span class="sxs-lookup"><span data-stu-id="cece5-250">`BasicHtmlWebResponseObject.Headers` values are now `String[]` instead of `String`.</span></span>
- <span data-ttu-id="cece5-251">`BasicHtmlWebResponseObject.BaseResponse` mostantól egy `System.Net.Http.HttpResponseMessage` objektum.</span><span class="sxs-lookup"><span data-stu-id="cece5-251">`BasicHtmlWebResponseObject.BaseResponse` is now a `System.Net.Http.HttpResponseMessage` object.</span></span>
- <span data-ttu-id="cece5-252">A `Response` webes parancsmag kivételek a tulajdonság már egy `System.Net.Http.HttpResponseMessage` objektum.</span><span class="sxs-lookup"><span data-stu-id="cece5-252">The `Response` property on Web Cmdlet exceptions is now a `System.Net.Http.HttpResponseMessage` object.</span></span>
- <span data-ttu-id="cece5-253">Az alapértelmezett szigorú RFC fejléc elemzés már a `-Headers` és `-UserAgent` paraméter.</span><span class="sxs-lookup"><span data-stu-id="cece5-253">Strict RFC header parsing is now default for the `-Headers` and `-UserAgent` parameter.</span></span> <span data-ttu-id="cece5-254">Ez is művelet megkerülését eredményezte az `-SkipHeaderValidation`.</span><span class="sxs-lookup"><span data-stu-id="cece5-254">This can be bypassed with `-SkipHeaderValidation`.</span></span>
- <span data-ttu-id="cece5-255">`file://` és `ftp://` URI sémák nem támogatottak.</span><span class="sxs-lookup"><span data-stu-id="cece5-255">`file://` and `ftp://` URI schemes are no longer supported.</span></span>
- <span data-ttu-id="cece5-256">`System.Net.ServicePointManager` beállítások a rendszer már nem figyelembe véve.</span><span class="sxs-lookup"><span data-stu-id="cece5-256">`System.Net.ServicePointManager` settings are no longer honored.</span></span>
- <span data-ttu-id="cece5-257">Jelenleg nincs Tanúsítványalapú hitelesítés elérhető MacOS-gépeken.</span><span class="sxs-lookup"><span data-stu-id="cece5-257">There is currently no certificate based authentication available on macOS.</span></span>
- <span data-ttu-id="cece5-258">Felhasználása `-Credential` keresztül egy `http://` URI-t egy hibát eredményez.</span><span class="sxs-lookup"><span data-stu-id="cece5-258">Use of `-Credential` over an `http://` URI will result in an error.</span></span> <span data-ttu-id="cece5-259">Használata egy `https://` URI-t, vagy adja meg a `-AllowUnencryptedAuthentication` paramétert a hibát.</span><span class="sxs-lookup"><span data-stu-id="cece5-259">Use an `https://` URI or supply the `-AllowUnencryptedAuthentication` parameter to suppress the error.</span></span>
- <span data-ttu-id="cece5-260">`-MaximumRedirection` most hoz létre egy hibát, átirányítás kísérletek-nál nagyobb a megadott korlátot, az utolsó átirányítás eredményeinek visszaadása helyett.</span><span class="sxs-lookup"><span data-stu-id="cece5-260">`-MaximumRedirection` now produces a terminating error when redirection attempts exceed the provided limit instead of returning the results of the last redirection.</span></span>
